#!/usr/bin/env node

const { spawn } = require('child_process');
const fs = require('fs').promises;
const path = require('path');

// Test categories and their configurations
const TEST_CATEGORIES = {
    unit: {
        pattern: 'tests/**/*.test.js',
        exclude: ['tests/load.test.js', 'tests/e2e.test.js'],
        description: '🧪 Unit and Integration Tests',
        timeout: 300000,
        coverage: true
    },
    load: {
        pattern: 'tests/load.test.js',
        exclude: [],
        description: '🚀 Load and Performance Tests',
        timeout: 600000,
        coverage: false,
        maxWorkers: 1
    },
    e2e: {
        pattern: 'tests/e2e.test.js',
        exclude: [],
        description: '🌐 End-to-End Tests',
        timeout: 900000,
        coverage: false,
        maxWorkers: 1
    },
    security: {
        pattern: 'tests/**/*.security.test.js',
        exclude: [],
        description: '🔒 Security Tests',
        timeout: 300000,
        coverage: true
    },
    all: {
        pattern: 'tests/**/*.test.js',
        exclude: [],
        description: '🎯 All Tests',
        timeout: 900000,
        coverage: true
    }
};

class TestRunner {
    constructor() {
        this.results = {};\n        this.startTime = Date.now();\n    }\n\n    async run(category = 'unit', options = {}) {\n        const testConfig = TEST_CATEGORIES[category];\n        if (!testConfig) {\n            console.error(`❌ Unknown test category: ${category}`);\n            console.log('Available categories:', Object.keys(TEST_CATEGORIES).join(', '));\n            process.exit(1);\n        }\n\n        console.log(`\\n${testConfig.description}`);\n        console.log('='.repeat(50));\n\n        // Prepare test environment\n        await this.prepareEnvironment(category);\n\n        // Build Jest command\n        const jestArgs = this.buildJestArgs(testConfig, options);\n\n        // Run tests\n        const success = await this.runJestTests(jestArgs, category);\n\n        // Generate report\n        await this.generateReport(category, success);\n\n        return success;\n    }\n\n    async prepareEnvironment(category) {\n        console.log('🔧 Preparing test environment...');\n\n        // Ensure test directories exist\n        const testDirs = [\n            'test-results',\n            'coverage',\n            'logs'\n        ];\n\n        for (const dir of testDirs) {\n            try {\n                await fs.mkdir(dir, { recursive: true });\n            } catch (error) {\n                if (error.code !== 'EEXIST') {\n                    console.warn(`⚠️  Failed to create ${dir}:`, error.message);\n                }\n            }\n        }\n\n        // Set test-specific environment variables\n        process.env.NODE_ENV = 'test';\n        process.env.TEST_CATEGORY = category;\n\n        // Category-specific setup\n        switch (category) {\n            case 'load':\n                process.env.MAX_SESSIONS = process.env.MAX_SESSIONS || '10';\n                process.env.LOAD_TEST = 'true';\n                break;\n            case 'e2e':\n                process.env.E2E_TEST = 'true';\n                process.env.HEADLESS = process.env.HEADLESS || 'true';\n                break;\n            case 'security':\n                process.env.SECURITY_TEST = 'true';\n                break;\n        }\n\n        // Check for required dependencies\n        await this.checkDependencies(category);\n    }\n\n    async checkDependencies(category) {\n        const requirements = {\n            all: ['tor', 'node'],\n            load: ['tor', 'node'],\n            e2e: ['tor', 'node', 'chromium'],\n            security: ['tor', 'node']\n        };\n\n        const required = requirements[category] || requirements.all;\n\n        for (const dep of required) {\n            try {\n                switch (dep) {\n                    case 'tor':\n                        await this.runCommand('tor --version');\n                        console.log('✅ Tor is available');\n                        break;\n                    case 'node':\n                        console.log(`✅ Node.js ${process.version} is available`);\n                        break;\n                    case 'chromium':\n                        // This will be checked by Puppeteer\n                        console.log('📋 Chromium will be checked by Puppeteer');\n                        break;\n                }\n            } catch (error) {\n                console.error(`❌ Missing dependency: ${dep}`);\n                console.error(`Please install ${dep} before running tests`);\n                process.exit(1);\n            }\n        }\n    }\n\n    buildJestArgs(testConfig, options) {\n        const args = [\n            '--config', 'jest.config.js',\n            '--testTimeout', testConfig.timeout.toString()\n        ];\n\n        // Test pattern\n        args.push('--testPathPattern', testConfig.pattern);\n\n        // Exclude patterns\n        if (testConfig.exclude.length > 0) {\n            args.push('--testPathIgnorePatterns');\n            args.push(...testConfig.exclude);\n        }\n\n        // Coverage\n        if (testConfig.coverage && !options.noCoverage) {\n            args.push('--coverage');\n        } else {\n            args.push('--coverage=false');\n        }\n\n        // Workers\n        if (testConfig.maxWorkers) {\n            args.push('--maxWorkers', testConfig.maxWorkers.toString());\n        }\n\n        // Verbose output\n        if (options.verbose || process.env.VERBOSE === 'true') {\n            args.push('--verbose');\n        }\n\n        // Watch mode\n        if (options.watch) {\n            args.push('--watch');\n        }\n\n        // Bail on first failure\n        if (options.bail || process.env.CI === 'true') {\n            args.push('--bail');\n        }\n\n        // Update snapshots\n        if (options.updateSnapshots) {\n            args.push('--updateSnapshot');\n        }\n\n        return args;\n    }\n\n    async runJestTests(jestArgs, category) {\n        console.log(`🚀 Running ${category} tests...`);\n        console.log('Command:', 'npx jest', jestArgs.join(' '));\n\n        return new Promise((resolve) => {\n            const jest = spawn('npx', ['jest', ...jestArgs], {\n                stdio: 'inherit',\n                env: { ...process.env }\n            });\n\n            jest.on('close', (code) => {\n                const success = code === 0;\n                this.results[category] = {\n                    success,\n                    code,\n                    duration: Date.now() - this.startTime\n                };\n\n                if (success) {\n                    console.log(`\\n✅ ${category} tests completed successfully`);\n                } else {\n                    console.log(`\\n❌ ${category} tests failed with code ${code}`);\n                }\n\n                resolve(success);\n            });\n\n            jest.on('error', (error) => {\n                console.error(`\\n💥 Failed to run tests:`, error.message);\n                this.results[category] = {\n                    success: false,\n                    error: error.message,\n                    duration: Date.now() - this.startTime\n                };\n                resolve(false);\n            });\n        });\n    }\n\n    async generateReport(category, success) {\n        const duration = Date.now() - this.startTime;\n        const report = {\n            category,\n            success,\n            duration,\n            timestamp: new Date().toISOString(),\n            environment: {\n                node: process.version,\n                platform: process.platform,\n                arch: process.arch\n            },\n            results: this.results\n        };\n\n        // Save detailed report\n        const reportPath = `test-results/test-report-${category}-${Date.now()}.json`;\n        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n        console.log(`📊 Detailed report saved to: ${reportPath}`);\n\n        // Print summary\n        this.printSummary(report);\n    }\n\n    printSummary(report) {\n        console.log('\\n' + '='.repeat(50));\n        console.log('📋 TEST SUMMARY');\n        console.log('='.repeat(50));\n        console.log(`Category: ${report.category}`);\n        console.log(`Status: ${report.success ? '✅ PASSED' : '❌ FAILED'}`);\n        console.log(`Duration: ${Math.round(report.duration / 1000)}s`);\n        console.log(`Timestamp: ${report.timestamp}`);\n        console.log(`Platform: ${report.environment.platform} ${report.environment.arch}`);\n        console.log(`Node.js: ${report.environment.node}`);\n        console.log('='.repeat(50));\n    }\n\n    async runCommand(command) {\n        return new Promise((resolve, reject) => {\n            const [cmd, ...args] = command.split(' ');\n            const child = spawn(cmd, args, { stdio: 'pipe' });\n\n            let stdout = '';\n            let stderr = '';\n\n            child.stdout.on('data', (data) => {\n                stdout += data.toString();\n            });\n\n            child.stderr.on('data', (data) => {\n                stderr += data.toString();\n            });\n\n            child.on('close', (code) => {\n                if (code === 0) {\n                    resolve(stdout);\n                } else {\n                    reject(new Error(`Command failed: ${stderr || stdout}`));\n                }\n            });\n\n            child.on('error', reject);\n        });\n    }\n}\n\n// CLI interface\nif (require.main === module) {\n    const args = process.argv.slice(2);\n    const category = args[0] || 'unit';\n\n    const options = {\n        verbose: args.includes('--verbose'),\n        watch: args.includes('--watch'),\n        bail: args.includes('--bail'),\n        noCoverage: args.includes('--no-coverage'),\n        updateSnapshots: args.includes('--update-snapshots')\n    };\n\n    const runner = new TestRunner();\n\n    runner.run(category, options)\n        .then((success) => {\n            process.exit(success ? 0 : 1);\n        })\n        .catch((error) => {\n            console.error('💥 Test runner failed:', error);\n            process.exit(1);\n        });\n}\n\nmodule.exports = TestRunner;\n"}}
</function_results>

<function_results>{"file_content_after_create":{"path":"/home/mans/web3-tor-browser-app/scripts/test-runner.js","content":"#!/usr/bin/env node\n\nconst { spawn } = require('child_process');\nconst fs = require('fs').promises;\nconst path = require('path');\n\n// Test categories and their configurations\nconst TEST_CATEGORIES = {\n    unit: {\n        pattern: 'tests/**/*.test.js',\n        exclude: ['tests/load.test.js', 'tests/e2e.test.js'],\n        description: '🧪 Unit and Integration Tests',\n        timeout: 300000,\n        coverage: true\n    },\n    load: {\n        pattern: 'tests/load.test.js',\n        exclude: [],\n        description: '🚀 Load and Performance Tests',\n        timeout: 600000,\n        coverage: false,\n        maxWorkers: 1\n    },\n    e2e: {\n        pattern: 'tests/e2e.test.js',\n        exclude: [],\n        description: '🌐 End-to-End Tests',\n        timeout: 900000,\n        coverage: false,\n        maxWorkers: 1\n    },\n    security: {\n        pattern: 'tests/**/*.security.test.js',\n        exclude: [],\n        description: '🔒 Security Tests',\n        timeout: 300000,\n        coverage: true\n    },\n    all: {\n        pattern: 'tests/**/*.test.js',\n        exclude: [],\n        description: '🎯 All Tests',\n        timeout: 900000,\n        coverage: true\n    }\n};\n\nclass TestRunner {\n    constructor() {\n        this.results = {};\n        this.startTime = Date.now();\n    }\n\n    async run(category = 'unit', options = {}) {\n        const testConfig = TEST_CATEGORIES[category];\n        if (!testConfig) {\n            console.error(`❌ Unknown test category: ${category}`);\n            console.log('Available categories:', Object.keys(TEST_CATEGORIES).join(', '));\n            process.exit(1);\n        }\n\n        console.log(`\\n${testConfig.description}`);\n        console.log('='.repeat(50));\n\n        // Prepare test environment\n        await this.prepareEnvironment(category);\n\n        // Build Jest command\n        const jestArgs = this.buildJestArgs(testConfig, options);\n\n        // Run tests\n        const success = await this.runJestTests(jestArgs, category);\n\n        // Generate report\n        await this.generateReport(category, success);\n\n        return success;\n    }\n\n    async prepareEnvironment(category) {\n        console.log('🔧 Preparing test environment...');\n\n        // Ensure test directories exist\n        const testDirs = [\n            'test-results',\n            'coverage',\n            'logs'\n        ];\n\n        for (const dir of testDirs) {\n            try {\n                await fs.mkdir(dir, { recursive: true });\n            } catch (error) {\n                if (error.code !== 'EEXIST') {\n                    console.warn(`⚠️  Failed to create ${dir}:`, error.message);\n                }\n            }\n        }\n\n        // Set test-specific environment variables\n        process.env.NODE_ENV = 'test';\n        process.env.TEST_CATEGORY = category;\n\n        // Category-specific setup\n        switch (category) {\n            case 'load':\n                process.env.MAX_SESSIONS = process.env.MAX_SESSIONS || '10';\n                process.env.LOAD_TEST = 'true';\n                break;\n            case 'e2e':\n                process.env.E2E_TEST = 'true';\n                process.env.HEADLESS = process.env.HEADLESS || 'true';\n                break;\n            case 'security':\n                process.env.SECURITY_TEST = 'true';\n                break;\n        }\n\n        // Check for required dependencies\n        await this.checkDependencies(category);\n    }\n\n    async checkDependencies(category) {\n        const requirements = {\n            all: ['tor', 'node'],\n            load: ['tor', 'node'],\n            e2e: ['tor', 'node', 'chromium'],\n            security: ['tor', 'node']\n        };\n\n        const required = requirements[category] || requirements.all;\n\n        for (const dep of required) {\n            try {\n                switch (dep) {\n                    case 'tor':\n                        await this.runCommand('tor --version');\n                        console.log('✅ Tor is available');\n                        break;\n                    case 'node':\n                        console.log(`✅ Node.js ${process.version} is available`);\n                        break;\n                    case 'chromium':\n                        // This will be checked by Puppeteer\n                        console.log('📋 Chromium will be checked by Puppeteer');\n                        break;\n                }\n            } catch (error) {\n                console.error(`❌ Missing dependency: ${dep}`);\n                console.error(`Please install ${dep} before running tests`);\n                process.exit(1);\n            }\n        }\n    }\n\n    buildJestArgs(testConfig, options) {\n        const args = [\n            '--config', 'jest.config.js',\n            '--testTimeout', testConfig.timeout.toString()\n        ];\n\n        // Test pattern\n        args.push('--testPathPattern', testConfig.pattern);\n\n        // Exclude patterns\n        if (testConfig.exclude.length > 0) {\n            args.push('--testPathIgnorePatterns');\n            args.push(...testConfig.exclude);\n        }\n\n        // Coverage\n        if (testConfig.coverage && !options.noCoverage) {\n            args.push('--coverage');\n        } else {\n            args.push('--coverage=false');\n        }\n\n        // Workers\n        if (testConfig.maxWorkers) {\n            args.push('--maxWorkers', testConfig.maxWorkers.toString());\n        }\n\n        // Verbose output\n        if (options.verbose || process.env.VERBOSE === 'true') {\n            args.push('--verbose');\n        }\n\n        // Watch mode\n        if (options.watch) {\n            args.push('--watch');\n        }\n\n        // Bail on first failure\n        if (options.bail || process.env.CI === 'true') {\n            args.push('--bail');\n        }\n\n        // Update snapshots\n        if (options.updateSnapshots) {\n            args.push('--updateSnapshot');\n        }\n\n        return args;\n    }\n\n    async runJestTests(jestArgs, category) {\n        console.log(`🚀 Running ${category} tests...`);\n        console.log('Command:', 'npx jest', jestArgs.join(' '));\n\n        return new Promise((resolve) => {\n            const jest = spawn('npx', ['jest', ...jestArgs], {\n                stdio: 'inherit',\n                env: { ...process.env }\n            });\n\n            jest.on('close', (code) => {\n                const success = code === 0;\n                this.results[category] = {\n                    success,\n                    code,\n                    duration: Date.now() - this.startTime\n                };\n\n                if (success) {\n                    console.log(`\\n✅ ${category} tests completed successfully`);\n                } else {\n                    console.log(`\\n❌ ${category} tests failed with code ${code}`);\n                }\n\n                resolve(success);\n            });\n\n            jest.on('error', (error) => {\n                console.error(`\\n💥 Failed to run tests:`, error.message);\n                this.results[category] = {\n                    success: false,\n                    error: error.message,\n                    duration: Date.now() - this.startTime\n                };\n                resolve(false);\n            });\n        });\n    }\n\n    async generateReport(category, success) {\n        const duration = Date.now() - this.startTime;\n        const report = {\n            category,\n            success,\n            duration,\n            timestamp: new Date().toISOString(),\n            environment: {\n                node: process.version,\n                platform: process.platform,\n                arch: process.arch\n            },\n            results: this.results\n        };\n\n        // Save detailed report\n        const reportPath = `test-results/test-report-${category}-${Date.now()}.json`;\n        await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n        console.log(`📊 Detailed report saved to: ${reportPath}`);\n\n        // Print summary\n        this.printSummary(report);\n    }\n\n    printSummary(report) {\n        console.log('\\n' + '='.repeat(50));\n        console.log('📋 TEST SUMMARY');\n        console.log('='.repeat(50));\n        console.log(`Category: ${report.category}`);\n        console.log(`Status: ${report.success ? '✅ PASSED' : '❌ FAILED'}`);\n        console.log(`Duration: ${Math.round(report.duration / 1000)}s`);\n        console.log(`Timestamp: ${report.timestamp}`);\n        console.log(`Platform: ${report.environment.platform} ${report.environment.arch}`);\n        console.log(`Node.js: ${report.environment.node}`);\n        console.log('='.repeat(50));\n    }\n\n    async runCommand(command) {\n        return new Promise((resolve, reject) => {\n            const [cmd, ...args] = command.split(' ');\n            const child = spawn(cmd, args, { stdio: 'pipe' });\n\n            let stdout = '';\n            let stderr = '';\n\n            child.stdout.on('data', (data) => {\n                stdout += data.toString();\n            });\n\n            child.stderr.on('data', (data) => {\n                stderr += data.toString();\n            });\n\n            child.on('close', (code) => {\n                if (code === 0) {\n                    resolve(stdout);\n                } else {\n                    reject(new Error(`Command failed: ${stderr || stdout}`));\n                }\n            });\n\n            child.on('error', reject);\n        });\n    }\n}\n\n// CLI interface\nif (require.main === module) {\n    const args = process.argv.slice(2);\n    const category = args[0] || 'unit';\n\n    const options = {\n        verbose: args.includes('--verbose'),\n        watch: args.includes('--watch'),\n        bail: args.includes('--bail'),\n        noCoverage: args.includes('--no-coverage'),\n        updateSnapshots: args.includes('--update-snapshots')\n    };\n\n    const runner = new TestRunner();\n\n    runner.run(category, options)\n        .then((success) => {\n            process.exit(success ? 0 : 1);\n        })\n        .catch((error) => {\n            console.error('💥 Test runner failed:', error);\n            process.exit(1);\n        });\n}\n\nmodule.exports = TestRunner;\n"}}
</function_results>

Now let me update the package.json to include the testing dependencies and scripts:

<function_calls>
<invoke name="read_files">
<parameter name="files">
<parameter name="path">/home/mans/web3-tor-browser-app/package.json
